\documentclass[10pt, a4paper,english,spanish,hidelinks]{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{caratula}
\usepackage[spanish, activeacute]{babel}
\usepackage[usenames,dvipsnames]{color}
\usepackage[width=15.5cm, left=3cm, top=2.5cm, height= 24.5cm]{geometry}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{multicol}
\usepackage{subfig}
\usepackage{float}
\usepackage{color,hyperref}


\usepackage{listings}
\usepackage{babel}
\usepackage{url}
\usepackage{lscape}
\parindent = 15 pt
\parskip = 11 pt

\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{color}
\usepackage{appendix}
\usepackage{fancyhdr}


\materia{Paradigmas de Lenguajes de Programación}

\titulo{Trabajo Práctico 2}
\fecha{04 de Noviembre de 2014}
\grupo{Grupo tas lokito}
\integrante{Gauder María Lara}{027/10}{marialaraa@gmail.com}
\integrante{Mataloni Alejandro}{706/07}{amataloni@gmail.com}
\integrante{Reartes Marisol}{422/10}{marisol.r5@hotmail.com}


\begin{document}
\pagestyle{myheadings}
\maketitle
\markboth{Paradigmas de Lenguajes de Programación}{}

\thispagestyle{empty}
\tableofcontents
\newpage
\section{Código y comentarios}
A continuación se muestra cada función con su explicación.

\subsection{Funciones auxiliares}

Auxiliar dada en clase
\begin{verbatim}
%desde(+X, -Y).
desde(X, X).
desde(X, Y):-
  desde(X, Z),
  Y is Z + 1.
\end{verbatim}


Se eliminan los elementos duplicados de la primer lista L1.
\begin{verbatim}
%sacarDup(+L1, -L2).
sacarDup([],[]).
sacarDup([X|L],L2):-
  member(X,L),
  !,
  sacarDup(L,L2).
sacarDup([X|L],[X|L2]):-
  not(member(X,L)), sacarDup(L,L2).
\end{verbatim}

Si ambas están definidas, retorna true si las dos son iguales.
Si una está instanciada y la otra no, genera la misma lista.
Y si las dos no están definidas, genera dos listas iguales.

\begin{verbatim}
%sameList(?L1, ?L2).
sameList([],[]).
sameList([X|Xs],[X|Ys]) :- 
  sameList(Xs,Ys).
\end{verbatim}

\subsection{Ejercicio1}

\begin{verbatim}
%esDeterministico(+Automata)
esDeterministico(Automata):-
  not(noEsDeterministico(Automata)).
\end{verbatim}

\begin{verbatim}
% noEsDeterministico(+Automata)
noEsDeterministico(Automata) :- 
  transicionesDe(Automata,T),
  member((O1,E1,D1), T),
  member((O2,E2,D2),T),
  O1 = O2,
  E1 = E2,
  D1 \= D2.


\end{verbatim}
Ejemplo:

\subsection{Ejercicio 2}

\begin{verbatim}
% estados(+Automata, ?Estados)
estados(Automata, Estados):-
  var(Estados),
  listaEstadosConRepetidos(Automata, EstadosConRepetidos),
  sort(EstadosConRepetidos, Estados).

estados(Automata, Estados):-
  nonvar(Estados),
  listaEstadosConRepetidos(Automata, EstadosConRepetidos),
  forall(member(E, EstadosConRepetidos), member(E, Estados)). 
\end{verbatim} 

genera en EstadosConRepetidos lista con el estado inicial, 
con los estados de origen y destinos de las transicones del autómata y con
los estados finales.

\begin{verbatim}
% listaEstadosConRepetidos(+Automata, -EstadosConRepetidos):-
listaEstadosConRepetidos(Automata, EstadosConRepetidos):-
  inicialDe(Automata, Si),
  transicionesDe(Automata, Transiciones),
  origenesydstAutomata(Transiciones, ODs),
  finalesDe(Automata, Finales),
  append([Si|ODs], Finales, EstadosConRepetidos).
\end{verbatim}


A partir de las transiciones de un automata, retorna una lista con todos los estados
que participan de alguna transición.

\begin{verbatim}
% origenesydstAutomata(+Ts, ?L).
origenesydstAutomata([], []).
origenesydstAutomata([(O,_,D)|Ts], [O,D|ODs]) :- origenesydstAutomata(Ts, ODs).
\end{verbatim}


\subsection{Ejercicio 3}
\begin{verbatim}
% esCamino(+Automata, ?EstadoInicial, ?EstadoFinal, +Camino)
esCamino(Automata, Si, Si, [Si]):-
  estados(Automata, Estados),
  member(Si, Estados).
esCamino(Automata, Si, Sf, [Si|C]):-
  last(C,Sf2),
  Sf = Sf2,
  transicionesDe(Automata, Transiciones),
  estanEn([Si|C], Transiciones).

%estanEn(-L1, +T)
estanEn([O,D], L2):-
  member((O,_,D), L2),
  !.
estanEn([O,D|L1], L2):-
  member((O,_,D), L2),
  !,
  estanEn([D|L1], L2).									
\end{verbatim}

Ejemplo:

\subsection{Ejercicio 4}

No, no es reversible. 
Esto se debe a la forma de recorrer el camino para la verificación. No se tiene
en cuenta el caso de generación del camino.
El predicado genera los posibles caminos cuando no hay ciclo y luego se cuelga.
Cuando hay ciclo, genera algunos caminos pero no todos, ya que se queda en el loop,
y sigue infinitamente generando por la misma rama.


\subsection{Ejercicio 5}

\begin{verbatim}
% caminoDeLongitud(+Automata, +N, -Camino, -Etiquetas, ?S1, ?S2)
caminoDeLongitud(Automata, 1, [Si], [], Si, Si):-
  !,
  estados(Automata, Estados),
  member(Si, Estados).
caminoDeLongitud(Automata, N, Camino, Etiquetas, Si, Sf):- N > 1,
  estados(Automata, Estados),
  member(Si, Estados),
  member(Sf, Estados),
  transicionesDe(Automata,Transiciones),
  Nm1 is N-1,
  crearCaminoConEtiquetas(Si, Sf, Transiciones, Camino, Nm1, Etiquetas).
\end{verbatim}


Dado dos estados que serán el principio y el final del camino, genera los caminos de
tamaño N con sus respectivas etiquetas. 

\begin{verbatim}
%crearCamino(?Si, ?Sf, +T, -Camino, +N, -Etiquetas).
crearCaminoConEtiquetas(X, Sf, Transiciones, [X,Sf], 1, [Etiqueta]):-
  !,
  member((X,Etiqueta,Sf),Transiciones).
crearCaminoConEtiquetas(X, Sf, Transiciones, [X|C], N, [E|Etiquetas]):-
  Nm1 is N-1,
  member((X,E,Y),Transiciones),
  crearCaminoConEtiquetas(Y, Sf, Transiciones, C, Nm1, Etiquetas).
\end{verbatim}

Ejemplo:

\subsection{Ejercicio 6}
Se utiliza Generate & Test.
\begin{verbatim}
% alcanzable(+Automata, +Estado)
alcanzable(Automata, Estado):-
  inicialDe(Automata, Inicial),
  estados(Automata,Estados),
  length(Estados, N),
  Nm1 is N+1,
  between(2, Nm1, M),
  caminoDeLongitud(Automata, M, _, _, Inicial, Estado),
  !.
\end{verbatim}

Ejemplo:


\subsection{Ejercicio 7}
\begin{verbatim}
% automataValido(+Automata)
automataValido(Automata):-
  estados(Automata, Estados),
  finalesDe(Automata, Finales),
  subtract(Estados, Finales, EstadosNoFinales),
  inicialDe(Automata, Inicial),
  subtract(Estados, [Inicial], EstadosNoIniciales),
  transicionesDe(Automata, Transiciones),
  todosTienenTransicionesSalientes(EstadosNoFinales, Transiciones),
  todosAlcanzables(Automata, EstadosNoIniciales),
  hayEstadoFinal(Finales),
  noHayFinalesRepetidos(Finales),
  noHayTransicionesRep(Transiciones).
\end{verbatim}
						
Verifica que todos los estados tienen transiciones salientes exceptuando los finales, que pueden
o no tenerlas.
\begin{verbatim}
%todosTienenTransicionesSalientes(+Estados, +Transiciones)
todosTienenTransicionesSalientes(Es, Ts):- 
  forall(member(E,Es), member((E, _, _), Ts)).
\end{verbatim}

Verifica que todos los estados son alcanzables desde el estado inicial.
\begin{verbatim}
%todosAlcanzables(+Automata, +Es)
todosAlcanzables(A, Es):- 
  forall(member(E, Es), alcanzable(A,E)). 
\end{verbatim}

Se comprueba que el automata tiene al menos un estado final.
\begin{verbatim}
%hayEstadoFinal(+Fs)
hayEstadoFinal(Fs):- 
  length(Fs, N), 
  N > 0.
\end{verbatim}

Se chequea que no hay estados finales repetidos.
\begin{verbatim}
%noHayFinalesRepetidos(+Fs)
noHayFinalesRepetidos(Fs):- 
  sacarDup(Fs, FsSinDup), 
  length(Fs, N), 
  length(FsSinDup, N).
\end{verbatim}

Se fija que no haya transiciones repetidas.
\begin{verbatim}
%noHayTransicionesRep(+Ts)
noHayTransicionesRep(Ts):- 
  sacarDup(Ts, TsSinDup), 
  length(Ts, N), 
  length(TsSinDup, N).
\end{verbatim}

Ejemplo:


\subsection{Ejercicio 8}

Se utiliza Generate & Test.

\begin{verbatim}
% hayCiclo(+Automata)
hayCiclo(Automata):-
  estados(Automata, Estados),
  length(Estados, M),
  P is M + 1,
  member(Estado, Estados),
  between(2, P, N),
  caminoDeLongitud(Automata, N, _, _, Estado, Estado), !.

\end{verbatim}

Ejemplo:

\subsection{Ejercicio 9}

Se utiliza Generate & Test.
\begin{verbatim}
% reconoce(+Automata, ?Palabra)
reconoce(Automata, Palabra):-
  nonvar(Palabra),
  length(Palabra,N),
  inicialDe(Automata,Si),
  finalesDe(Automata,Finales),
  member(Sf,Finales),
  Nm1 is N+1,
  caminoDeLongitud(Automata,Nm1,_,TmpPalabra,Si,Sf),
  sameList(Palabra,TmpPalabra).

reconoce(Automata, Palabra):-
  var(Palabra),
  not(hayCiclo(Automata)),
  inicialDe(Automata,Si),
  finalesDe(Automata,Finales),
  transicionesDe(Automata,Transiciones),
  length(Transiciones,N), Nm1 is N+1,
  between(1, Nm1, Tam),
  member(Sf,Finales),
  caminoDeLongitud(Automata,Tam,_,Palabra,Si,Sf).

reconoce(Automata, Palabra):-
  var(Palabra),
  hayCiclo(Automata),
  inicialDe(Automata,Si),
  finalesDe(Automata,Finales),
  desde(1, N),
  member(Sf,Finales),
  caminoDeLongitud(Automata,N,_,Palabra,Si,Sf).
\end{verbatim}

Ejemplo:


\subsection{Ejercicio 10}

Se utiliza Generate & Test.

\begin{verbatim}
% PalabraMásCorta(+Automata, ?Palabra)
palabraMasCorta(Automata, Palabra):-
  nonvar(Palabra),
  reconoce(Automata,Palabra),
  transicionesDe(Automata,Transiciones),
  length(Transiciones,N),
  Nm1 is N+1,
  inicialDe(Automata,Si),
  finalesDe(Automata,Sfs),
  between(1,Nm1,Tam),
  member(Sf,Sfs),
  caminoDeLongitud(Automata,Tam,_,_,Si,Sf),
  !,
  Tam2 is Tam -1,
  length(Palabra,TamPal), Tam2 = TamPal.
palabraMasCorta(Automata, Palabra):-
  var(Palabra),
  transicionesDe(Automata,Transiciones),
  length(Transiciones,N), Nm1 is N+1,
  inicialDe(Automata,Si),
  finalesDe(Automata,Sfs),
  between(1,Nm1,Tam),
  member(Sf,Sfs),
  caminoDeLongitud(Automata,Tam,_,_,Si,Sf),
  !,
  Len is Tam - 1,
  reconoceAcotado(Automata, Palabra, Len).


\end{verbatim}
							
Se utiliza Generate & Test.
Genera todas las palabras de longitud N de un automata dado.
\begin{verbatim}
% reconoceAcotado(+A, ?P, +N)
reconoceAcotado(Automata, Palabra, N):-
  length(Palabra, N),
  reconoce(Automata, Palabra).

\end{verbatim}

Ejemplo:


\end{document}
